/**
 * @file   3d_prl_het_cst_load_fracture_checkerboard.cc
 * @author Thibault Roch <thibault.roch@epfl.ch>
 * @date   Fri Sept 18 14:12:03 2018
 *
 * @brief  3d interface with a checkboard pattern of asperities
 *
 * @section LICENSE
 *
 * cRacklet - A spectral boundary integral method for interface fracture simulation 
 * Copyright (©) 2012 - 2013 Fabian Barras 
 *               2014 EPFL (Ecole Polytechnique Fédérale de Lausanne) 
 *  
 * cRacklet is the result of a collaboration between the Computational Solid Mechanics  
 * Laboratory (LSMS) of Ecole Polytechnique Fédérale de Lausanne (EPFL), Switzerland  
 * and the Department of Aerospace Engineering of the University of Illinois at  
 * Urbana-Champaign, United States of America. 
 *  
 * cRacklet is free software: you can redistribute it and/or modify it under the terms  
 * of the GNU General Public License as published by the Free Software Foundation,  
 * either version 3 of the License, or (at your option) any later version. 
 *  
 * cRacklet is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;  
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   
 * See the GNU General Public License for more details. 
 *  
 * You should have received a copy of the GNU General Public License along with this program.   
 * If not, see <http://www.gnu.org/licenses/>.
 *
 */

/* -------------------------------------------------------------------------- */
#include "spectral_model.hh"
#include "simulation_driver.hh"
#include "interfacer.hh"
#include "cohesive_law.hh"
#include "coulomb_law.hh"
#include "regularized_coulomb_law.hh"
#include "data_dumper.hh"
#include <vector>
#include <iostream>
#include <stdio.h>
#include <string>
#include <iomanip>
#include <sys/stat.h>
/* -------------------------------------------------------------------------- */

int main(int argc, char *argv[]){
  
  // Note : Construct the pre-integrated material kernels before running this simulation
  // Use "invert_serial.f" to construct kernel files
  
  std::cout << "./3d_prl_het_cst_load_fracture_checkerboard [ <output_folder_name>=./ <nb_t_steps>=10000 <nb_ele_x>=8192 <nb_ele_z>=256 <size_heterog>=64 <loading_angle>=90 <load>=1.98 <strength_ratio>=0.2 <dom_size_x>=8 <dom_size_z>=0.25 ]" << std::endl;

  std::time_t start = std::time(NULL);
  Real duration;
  Real pausing_duration = 72*60*60;
  bool first_half = true;
  
  std::string sim_name = "Mode-II fracture along a 3d interface with a checkerboard pattern of asperities, at a controled rupture speed";
  
  // Geometry description
  UInt nb_time_steps = 100000; 
  UInt nex = 8192; 
  UInt nez = 256;
  Real nu =  0.35;
  Real E = 5.3e9;
  Real cs = 1263;
  
  // Cut of the loaded material kernels
  UInt tcut = 100; 
  
  // Loading case
  Real load = 1.98;
  Real psi = 90.0;
  Real phi = 0.0;
  
  Real size_heterog = 32;
  Real ratio = 0.2;

  // Output folder
  std::string output_folder = "./";
  if(argc > 1)
    output_folder = argv[1];
  
  if(argc > 2)
    nb_time_steps = std::atoi(argv[2]);
  
  if(argc > 3)
    nex = std::atoi(argv[3]);
  
  if(argc > 4)
    nez = std::atoi(argv[4]);
   
  if(argc > 5)
    size_heterog = std::atoi(argv[5]);
  
  if(argc > 6)
    psi = std::atof(argv[6]);
  
  if(argc > 7)
    load = std::atof(argv[7]);
  
  if(argc > 8)
    ratio = std::atof(argv[8]);

  load *=1.0e6;
  
  std::cout << "./3d_prl_het_cst_load_fracture_checkerboard " 
	    << "output folder:" << output_folder << " " 
	    << "nb_time steps:" << nb_time_steps << " " 
	    << "nb_elements_x:" << nex << " "
	    << "nb_elements_z:" << nez << " "
	    << "size_heterog:" << size_heterog << " "
	    << "strength_ratio:" << ratio << " "
	    << "load:" << load << " "
	    << "loading angle:" << psi << " "
	    << std::endl;
  
  // Cohesive parameters
  Real crit_n_open = 0.02e-3;//0.08e-3;
  Real crit_s_open = 0.02e-3;//0.08e-3;
  Real max_n_str = 9e6;//1.25e6;
  Real max_s_str = 9e6;//1.25e6;
  Real ratio_max_s_str = ratio;
  Real ratio_max_n_str = ratio;
  Real ratio_max_s_open = 0;
  Real ratio_max_n_open = 0;
  
  Real G_length;
  
  if (psi == 0)
    G_length = crit_n_open*max_n_str/(load*load*M_PI)*E/(1-nu*nu);
  
  else if (psi == 90)
    G_length = crit_s_open*max_s_str/(load*load*M_PI)*E/(1-nu*nu);
  
  std::cout << "Griffith length: " << G_length << std::endl; 
  
  Real dom_sizex = 8;
  Real dom_sizez = 0.25;
  
  if(argc > 9)
    dom_sizex = std::atof(argv[9]);
  
  if(argc > 10)
    dom_sizez = std::atof(argv[10]);
  
  dom_sizex *= G_length;
  dom_sizez *= G_length;
  
  Real dx = dom_sizex/(Real)(nex);
  Real dz = dom_sizez/(Real)(nez);
  Real wall_position = 0.95*dom_sizex;
  UInt propagation_domain = 2./3.*nex;
  
  std::cout << "Wall position:" << wall_position << " "
	    << "Propagation domain:" << propagation_domain << " "
	    << std::endl;

  size_heterog *= dx;
  Real heter_start_x = 2*G_length;
  Real heter_end_x = 5*G_length;
  Real heter_start_z = 0;
  Real heter_end_z = dom_sizez;
  Real nb_heterog_x = (heter_end_x - heter_start_x)/(2*size_heterog);
  Real nb_heterog_z = (heter_end_z - heter_start_z)/(2*size_heterog);
  
  Real crack_size = 10*dx;
    
  bool tracking = 0;

  /* -------------------------------------------------------------------------- */

  UInt t = 0;
  UInt x_tip = 0;
  UInt x_lap = 0.05*nex;

  std::string outfolder;
  
  UInt nb_simulation_phases;
  if(ratio == 0.)  // If ratio = 0, no asperities
    nb_simulation_phases=1;
  else
    nb_simulation_phases=2;

  for (UInt phase = 0; phase < nb_simulation_phases; ++phase) {
    
    SpectralModel * model;
    
    if ((ratio==0.)||(phase==0)){
      outfolder = output_folder + "2d_outputs/";
      mkdir(outfolder.c_str(),0777);
      
#if defined (_OPENMP)
      max_num_threads = omp_get_max_threads();
      omp_set_num_threads(1);
#endif
      
      model = new SpectralModel({nex,1}, nb_time_steps, {dom_sizex,0.},
				nu, nu, E, E, cs, cs, tcut, tcut,
				sim_name, outfolder); 
    } else {
      outfolder = output_folder;
      mkdir(outfolder.c_str(),0777);

#if defined (_OPENMP)
      omp_set_num_threads(max_num_threads);
#endif

      model = new SpectralModel({nex,nez}, nb_time_steps, {dom_sizex,dom_sizez},
				nu, nu, E, E, cs, cs, tcut, tcut,
				sim_name, outfolder); 
    }
    
    SimulationDriver sim_driver(*model);
  
    Interfacer<_linear_coupled_cohesive> interfacer(*model);   

    DataRegister::registerParameter("critical_normal_opening",crit_n_open);
    DataRegister::registerParameter("critical_shear_opening",crit_s_open);
    DataRegister::registerParameter("max_normal_strength",max_n_str);
    DataRegister::registerParameter("max_shear_strength",max_s_str);
  
    interfacer.createUniformInterface();
    interfacer.createThroughCrack(0.,crack_size,2);
    
    if ((ratio!=0.)&&(phase == 1)){    
      interfacer.createCheckerboardPolarAsperity(heter_start_x,heter_end_x,
						 heter_start_z,heter_end_z,
						 nb_heterog_x,nb_heterog_z,
						 ratio_max_n_str,ratio_max_s_str,
						 ratio_max_n_open,ratio_max_s_open);
    }
    
    interfacer.createThroughWall(wall_position,dom_sizex);

    CohesiveLaw * cohesive_law = dynamic_cast<CohesiveLaw*>(*(model->getInterfaceLaw()));
    cohesive_law->preventSurfaceOverlapping(NULL);
    
    sim_driver.initConstantLoading(load, psi, phi);

    /* -------------------------------------------------------------------------- */
    //Set-up simulation  outputs
    
    DataDumper dumper(*model);
    
    dumper.initDumper("ST_Diagram_id.cra", _id_crack, 1.0, 1, 0, _binary);
    
    if(tracking == true)
      dumper.initDumper("ST_Diagram_nb.cra", _crack_number, 1.0, 1, 0, _binary);
    
    dumper.initDumper("trac_snapshot.cra",_interface_tractions,1.0,1,0,_binary);
    
    if (psi == 0){
      dumper.initDumper("ST_Diagram_normal_strength.cra", _normal_strength, 1., 1, 0, _binary);
      dumper.initDumper("ST_Diagram_normal_velo_jump.cra", _normal_velocity_jumps, 1.0, 1, 0, _binary);
    } else if (psi == 90){
      dumper.initDumper("ST_Diagram_shear_strength.cra", _shear_strength, 1., 1, 0, _binary);
      dumper.initDumper("ST_Diagram_shear_velo_jump.cra", _shear_velocity_jumps, 1., 1, 0, _binary);
    }

    if(phase == 1){
      DataRegister::restart_dir = "2d_outputs/restart_files/";
      model->restartModel(true);
    }
    
    if(phase == 0){
      sim_driver.launchCrack(0.,2*G_length,0.05);
    }

    while ((t < nb_time_steps)&&(x_tip<propagation_domain)){

      if (phase ==0){
	model->pauseModel();
	std::cout << "End of pseudo 2d" << std::endl;
	break;
      }

      sim_driver.solveStep();
      x_tip = model->getCrackTipPosition(0.,nex);
     
      if (t%25==0)
	dumper.dumpAll();
     
      if ((x_tip>x_lap)||(t%(UInt)(0.05*nb_time_steps)==0)) {
	std::cout << "Process at " << (Real)t/(Real)nb_time_steps*100 << "% " << std::endl;
	std::cout << "Crack at " << 100*x_tip/(Real)(nex) << "% " << std::endl;
	if (x_tip>x_lap)
	  x_lap += 0.05*nex;
      }
      ++t;
      
      duration = std::time(NULL) - start;

      if((duration>0.5*pausing_duration)&&(first_half)) {
	first_half = false;
	std::cout << "The simulation just passes half of his planned duration!" << std::endl;	
      }

    }

    if (phase ==0){
      delete model;
    }
  }
  return 0;
}
